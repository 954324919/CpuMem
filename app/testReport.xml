<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<redline>
<summary src=".">
<serial_no>1502012134366</serial_no>
<submitter>tester</submitter>
<reportname>testReport</reportname>
<project_name>test</project_name>
<version>1.2.5</version>
<filenum>25</filenum>
<linenum>15635</linenum>
<starttime>2017-08-06 17:35:34</starttime>
<endtime>2017-08-06 17:38:03</endtime>
<totaltime>2分28秒573毫秒</totaltime>
<blocknum>0</blocknum>
<errornum>4</errornum>
<warningnum>28</warningnum>
<suggestnum>2</suggestnum>
<errorfilenum>0</errorfilenum>
</summary>
<violations>
<violation>
<id>1-49</id>
<rulename>EmptyIfStmt</rulename>
<file>UpdateReceiver.java</file>
<class>com.example.administrator.cpumem.receivers.UpdateReceiver</class>
<position>方法:onReceive/n开始行:15/n结束行:17</position>
<description>发现使用 if 进行了条件判断，但是判断之后没做任何处理。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>DemoService.java</file>
<class>com.example.administrator.cpumem.service.DemoService</class>
<position>方法:onCreate/n行:15/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MyPermanceService.java</file>
<class>com.example.administrator.cpumem.service.MyPermanceService</class>
<position>方法:onCreate/n行:68/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MyPermanceService.java</file>
<class>com.example.administrator.cpumem.service.MyPermanceService</class>
<position>方法:closeOpenedStream/n行:319/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>JacocoInstrumentation.java</file>
<class>com.example.administrator.cpumem.test.JacocoInstrumentation</class>
<position>方法:generateCoverageReport/n行:60/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>JacocoInstrumentation.java</file>
<class>com.example.administrator.cpumem.test.JacocoInstrumentation</class>
<position>方法:generateCoverageReport/n行:70/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:readTotalCpuStat/n行:66/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>1-30</id>
<rulename>InefficientStringBuffering</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:readProcessCpuStat/n行:84/n</position>
<description>避免在StringBuffer的构造器或append()方法中连接非常量类型。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:readProcessCpuStat/n行:90/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:readProcessCpuStat/n行:93/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioInfo/n行:107/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioInfo/n行:108/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioInfo/n行:109/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioInfo/n行:111/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioCmd/n行:136/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioCmd/n行:138/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>CpuInfo.java</file>
<class>com.example.administrator.cpumem.utils.CpuInfo</class>
<position>方法:getCpuRatioCmd/n行:143/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:parseing/n行:104/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:parseing/n行:117/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:dalvikLimMem/n行:165/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:dalvikLimMem/n行:168/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:memRatioInfo/n行:187/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:memRatioInfo/n行:188/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:memRatioInfo/n行:189/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>PkgInfo.java</file>
<class>com.example.administrator.cpumem.utils.PkgInfo</class>
<position>方法:mypkgInfo/n行:33/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>SaveResult.java</file>
<class>com.example.administrator.cpumem.utils.SaveResult</class>
<position>方法:createRes/n行:60/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>SaveResult.java</file>
<class>com.example.administrator.cpumem.utils.SaveResult</class>
<position>方法:createRes/n行:61/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>SaveResult.java</file>
<class>com.example.administrator.cpumem.utils.SaveResult</class>
<position>方法:createRes/n行:62/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>3-3</id>
<rulename>LogOnOffRule</rulename>
<file>SaveResult.java</file>
<class>com.example.administrator.cpumem.utils.SaveResult</class>
<position>方法:createRes/n行:63/n</position>
<description>建议使用if(DEBUG)包裹Log方法,日志开关不要封装在日志函数中。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</violation>
<violation>
<id>4-12</id>
<rulename>AllowBackupRule</rulename>
<file>AndroidManifest.xml</file>
<class>C:\android_studio\myworkspace\CpuMem\.\app\build\intermediates\exploded-aar\com.github.markzhai\blockcanary-android\1.5.0\AndroidManifest.xml</class>
<class>C:\android_studio\myworkspace\CpuMem\.\app\build\intermediates\exploded-aar\com.github.markzhai\blockcanary-android\1.5.0\AndroidManifest.xml.AndroidManifest.xml</class>
<position>方法:application/n行:11/n</position>
<description>建议将AndroidMannifest.xml文件android:allowBackup属性设置为false。当allowBackup未设置值（默认值为true）或者标志值为true时，攻击者可通过adb backup和adb restore来备份和恢复应用程序数据。</description>
<ruletype>安全类</ruletype>
<priority>1</priority>
</violation>
<violation>
<id>2-8</id>
<rulename>FIRELINE_OS_OPEN_STREAM</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:parseing/n行:91/n</position>
<description>资源对象没有关闭。请确保输入输出流创建的对象在使用完成后进行了妥善的关闭处理。</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</violation>
<violation>
<id>2-8</id>
<rulename>FIRELINE_OS_OPEN_STREAM</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:parseing/n行:99/n</position>
<description>资源对象没有关闭。请确保输入输出流创建的对象在使用完成后进行了妥善的关闭处理。</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</violation>
<violation>
<id>2-8</id>
<rulename>FIRELINE_OS_OPEN_STREAM</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:runCMD/n行:70/n</position>
<description>资源对象没有关闭。请确保输入输出流创建的对象在使用完成后进行了妥善的关闭处理。</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</violation>
<violation>
<id>5-16</id>
<rulename>NP_NULL_ON_SOME_PATH_EXCEPTION</rulename>
<file>MemInfo.java</file>
<class>com.example.administrator.cpumem.utils.MemInfo</class>
<position>方法:runCMD/n行:64/n</position>
<description>异常路径存在空指针引用,执行时可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</violation>
</violations>
<passes>
<pass>
<id>5-11</id>
<rulename>NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</rulename>
<description>标记为非空的字段没有初始化,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-23</id>
<rulename>NP_SYNC_AND_NULL_CHECK_FIELD</rulename>
<description>使用同一个字段进行同步和非空检查,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-31</id>
<rulename>NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE</rulename>
<description>应该为非空的参数被标记为可为空,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-21</id>
<rulename>NP_STORE_INTO_NONNULL_FIELD</rulename>
<description>注释为@Nonnull的字段存进了可能为空的对象,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-5</id>
<rulename>NP_ALWAYS_NULL</rulename>
<description>此位置存在空指针引用,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>5-3</id>
<rulename>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</rulename>
<description>使用object.equals()方法时没有对object进行为空校验,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-9</id>
<rulename>NP_GUARANTEED_DEREF</rulename>
<description>分支语句运行时会生成空对象,该对象被引用可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-7</id>
<rulename>NP_ARGUMENT_MIGHT_BE_NULL</rulename>
<description>方法的参数在引用前没有进行为空校验,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-15</id>
<rulename>NP_NULL_ON_SOME_PATH</rulename>
<description>分支语句存在空指针引用,该语句执行时会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-27</id>
<rulename>NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION</rulename>
<description>重写后的方法应保持与被重写方法的参数一致性,比如把@Nullable的参数重写后设置为@Nonnull,这是不合理的。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-13</id>
<rulename>NP_NONNULL_RETURN_VIOLATION</rulename>
<description>标记为@Nonnull的方法可能返回null,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-25</id>
<rulename>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</rulename>
<description>readLine()结果被立即引用,如果没有行进行读取了,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-19</id>
<rulename>NP_NULL_PARAM_DEREF_NONVIRTUAL</rulename>
<description>给一个非空的方法参数传递一个可能为空的值,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-17</id>
<rulename>NP_NULL_PARAM_DEREF</rulename>
<description>该方法给一个非空的方法参数传递空值,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-29</id>
<rulename>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</rulename>
<description>应该检查是否为空的方法返回值没有进行为空检查,可能 会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-30</id>
<rulename>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</rulename>
<description>分支路径存在空指针引用,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-22</id>
<rulename>NP_UNWRITTEN_FIELD</rulename>
<description>程序关联字段未写入非空的值,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-12</id>
<rulename>NP_NONNULL_PARAM_VIOLATION</rulename>
<description>该方法给一个非空参数传了空值,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-20</id>
<rulename>NP_OPTIONAL_RETURN_NULL</rulename>
<description>使用java.util.Optional或者 com.google.common.base.Optiona类时,返回空值可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-10</id>
<rulename>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</rulename>
<description>异常路径上的分支语句运行时会生成空对象,该对象被引用可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-32</id>
<rulename>NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD</rulename>
<description>程序引用的公有的或者私有的字段没有被写入非空值,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-4</id>
<rulename>NP_TOSTRING_COULD_RETURN_NULL</rulename>
<description>此位置使用toString方法可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-2</id>
<rulename>NP_CLONE_COULD_RETURN_NULL</rulename>
<description>克隆的方法的可能返回null。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-8</id>
<rulename>NP_CLOSING_NULL</rulename>
<description>执行close()方法的对象为空,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-6</id>
<rulename>NP_ALWAYS_NULL_EXCEPTION</rulename>
<description>方法的异常处理过程存在空指针引用,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-1</id>
<rulename>NP_BOOLEAN_RETURN_NULL</rulename>
<description>方法的布尔返回值为null,会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-26</id>
<rulename>NP_LOAD_OF_KNOWN_NULL_VALUE</rulename>
<description>已经检查出为空的值仍被继续引用。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-24</id>
<rulename>NP_DEREFERENCE_OF_READLINE_VALUE</rulename>
<description>引用readLine()结果时没有进行非空校验,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-14</id>
<rulename>NP_NULL_INSTANCEOF</rulename>
<description>使用instance of方法判断为空对象的type,可能会导致空指针异常。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-28</id>
<rulename>NP_METHOD_RETURN_RELAXING_ANNOTATION</rulename>
<description>重写后的方法应保持与被重写方法的参数一致性,比如把@Nonnull的参数重写后设置为@Nullable或者@CheckForNull,这是不合理的。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>5-18</id>
<rulename>NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS</rulename>
<description>从外部传进的参数存在为空的可能,而使用该参数的方法要求该参数不能为空。</description>
<ruletype>空指针</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-41</id>
<rulename>WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL</rulename>
<description>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：
			 private static final String base = "label";
			 private static int nameCounter = 0;
			 String constructComponentName() {
				synchronized (getClass()) {
					return base + nameCounter++;
				}
			 }
			 Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：
			 private static final String base = "label";
			 private static int nameCounter = 0;
			 String constructComponentName() {
				synchronized (Label.class) { 
					return base + nameCounter++;
				}
			 }</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-31</id>
<rulename>STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE</rulename>
<description>在官方的JavaDoc，DateFormats多线程使用本身就是不安全的。建议的方法是在做日期转换之前，为DateFormat对象加锁或者使用ThreadLocal变量去容纳DateFormat对象，也就是说每个线程都有一个属于自己的副本，并无需等待其他线程去释放它。这种方法会比使用同步块更高效。。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-23</id>
<rulename>NP_SYNC_AND_NULL_CHECK_FIELD</rulename>
<description>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-13</id>
<rulename>JLM_JSR166_LOCK_MONITORENTER</rulename>
<description>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/release（）方法而不是使用同步的方法。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-35</id>
<rulename>UG_SYNC_SET_UNSYNC_GET</rulename>
<description>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-21</id>
<rulename>MWN_MISMATCHED_NOTIFY</rulename>
<description>此方法调用Object.notify()或Object.notifyAll()而没有获取到该对象的对象锁。调用notify()或notifyAll()而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-43</id>
<rulename>WA_AWAIT_NOT_IN_LOOP</rulename>
<description>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-11</id>
<rulename>IS2_INCONSISTENT_SYNC</rulename>
<description>同步存在一致性问题。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-33</id>
<rulename>STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE</rulename>
<description>在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些问题。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-5</id>
<rulename>DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE</rulename>
<description>该代码同步一个封装的原始常量，例如一个Integer类型。
				private static Integer count = 0;
				...
				  synchronized(count) {
					 count++;
					 }
				...
				由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-3</id>
<rulename>DC_PARTIALLY_CONSTRUCTED</rulename>
<description>使用double-checked locking进行lazy field initialization（延迟初始化）可能会存在问题，比如实例化对象在执行的时候会分为三步：分配内存，调用构造函数初始化，指向分配的内存，但是顺序不是固定的。如果在执行第二步的时候另外一个线程进入，发现对象非空则直接使用，则在后续会产生问题。在jdk5之后（包含JDK5）之后，可以使用volatile限制来定义instance，能够避免double-checked locking。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-9</id>
<rulename>DM_USELESS_THREAD</rulename>
<description>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-7</id>
<rulename>DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE</rulename>
<description>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。
				private static final Integer fileLock = new Integer(1);
				...
				  synchronized(fileLock) {
					 .. do something ..
					 }
				...
				对于上述代码中，fileLock对象被重新声明为下面这样会更好一些：
				private static final Object fileLock = new Object();</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-2</id>
<rulename>DC_DOUBLECHECK</rulename>
<description>这个方法可能包含一个被双重检查锁定住的实例。根据java内存模型的语义分析是不正确的用法。详情请见：http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-27</id>
<rulename>RU_INVOKE_RUN</rulename>
<description>这种方法显式调用一个对象的run()。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-17</id>
<rulename>LI_LAZY_INIT_UPDATE_STATIC</rulename>
<description>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-39</id>
<rulename>VO_VOLATILE_INCREMENT</rulename>
<description>volatile的自增操作不是原子的，如果同时有多个线程同时调用这个字段，增量就会出问题</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-25</id>
<rulename>RS_READOBJECT_SYNC</rulename>
<description>序列化类中定义了同步的readObject()。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject()进行同步。如果的readObject()方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-15</id>
<rulename>JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT</rulename>
<description>util.concurrent提供了await(), signal(), signalAll() 等方法，比如Condition 接口是 Object 中 wait() 和 notify() 方法的具体化。Lock 中的一个方法是 newCondition()，它要求锁定向该锁定返回新的 Condition 对象限制。await()、signal() 和 signalAll() 方法类似于 wait()、notify() 和 notifyAll()，但增加了灵活性，每个 Lock 都可以创建多个条件变量。这简化了一些并发算法的实现。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-37</id>
<rulename>UL_UNRELEASED_LOCK_EXCEPTION_PATH</rulename>
<description>方法获得了当前的对象锁，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：
				Lock l = ...;
				l.lock();
				try {
					// do something
				} finally {
					l.unlock();
			}</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-29</id>
<rulename>SP_SPIN_ON_FIELD</rulename>
<description>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-19</id>
<rulename>ML_SYNC_ON_UPDATED_FIELD</rulename>
<description>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-30</id>
<rulename>STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE</rulename>
<description>因为Calendar在使用多线程的情况下是天生不安全的，因此发出关于java.util.Calendar或java.text.DateFormat类型（及其子类）的静态字段的警报</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-20</id>
<rulename>MSF_MUTABLE_SERVLET_FIELD</rulename>
<description>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单例类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-42</id>
<rulename>WS_WRITEOBJECT_SYNC</rulename>
<description>这个类有一个writeObject()方法是同步的，但是这个类中没有其他的同步方法。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-40</id>
<rulename>VO_VOLATILE_REFERENCE_TO_ARRAY</rulename>
<description>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-12</id>
<rulename>IS_FIELD_NOT_GUARDED</rulename>
<description>此字段被标注为net.jcip.annotations.GuardedBy或javax.annotation.concurrent.GuardedBy，但可以在某种程度上违反注释而去访问。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-34</id>
<rulename>SWL_SLEEP_WITH_LOCK_HELD</rulename>
<description>当持有对象时调用Thread.sleep()。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-24</id>
<rulename>NO_NOTIFY_NOT_NOTIFYALL</rulename>
<description>调用notify()而不是notifyAll()方法。Java的监控器通常用于多个条件。调用notify()只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-10</id>
<rulename>ESync_EMPTY_SYNC</rulename>
<description>该代码包含一个空的同步块：synchronized(){}</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-32</id>
<rulename>STCAL_STATIC_CALENDAR_INSTANCE</rulename>
<description>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-22</id>
<rulename>MWN_MISMATCHED_WAIT</rulename>
<description>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait()而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-44</id>
<rulename>WA_NOT_IN_LOOP</rulename>
<description>这种方法包含调用java.lang.Object.wait()，而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-6</id>
<rulename>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</rulename>
<description>同步String类型对象，被占用。
				private static String LOCK = "LOCK";
				...
				  synchronized(LOCK) { ...}
				...
				同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-4</id>
<rulename>DL_SYNCHRONIZATION_ON_BOOLEAN</rulename>
<description>该代码同步一个封装的原始常量，例如一个Boolean类型。
				private static Boolean inited = Boolean.FALSE;
				...
				  synchronized(inited) {
					if (!inited) {
					   init();
					   inited = Boolean.TRUE;
					   }
					 }
				...
			由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-8</id>
<rulename>DM_MONITOR_WAIT_ON_CONDITION</rulename>
<description>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-1</id>
<rulename>AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION</rulename>
<description>这段代码包含并发抽象的调用序列，这些调用可能不是原子性的执行。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-16</id>
<rulename>LI_LAZY_INIT_STATIC</rulename>
<description>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-38</id>
<rulename>UW_UNCOND_WAIT</rulename>
<description>方法中包含调用java.lang.Object.wait()，而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-28</id>
<rulename>SC_START_IN_CTOR</rulename>
<description>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-14</id>
<rulename>JLM_JSR166_UTILCONCURRENT_MONITORENTER</rulename>
<description>在util.concurrent实例上执行同步方法，实际上无需这样做。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-36</id>
<rulename>UL_UNRELEASED_LOCK</rulename>
<description>方法获得了当前的对象锁，但是在方法中始终没有释放它。一个正确的示例如下：
				Lock l = ...;
				l.lock();
				try {
					// do something
				} finally {
					l.unlock();
				}</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-26</id>
<rulename>RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED</rulename>
<description>忽略putIfAbsent方法的返回值，重用传入putIfAbsent方法的参数值</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>6-18</id>
<rulename>ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD</rulename>
<description>作用在字段上的同步是没有意义的。这段代码在字段上做了同步用以防止字段被同步修改，然而同步锁是需要建立在该字段的引用对象上而不是该字段。</description>
<ruletype>多线程</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>1-40</id>
<rulename>UseEqualsToCompareStrings</rulename>
<description>使用‘==’或‘！=’比较字符串大小只是比较两边的常量池的引用。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-51</id>
<rulename>EmptyTryBlock</rulename>
<description>避免空的 try块</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-52</id>
<rulename>EmptyFinallyBlock</rulename>
<description>避免空的 finally 块 - 这些是可以删掉的。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-50</id>
<rulename>EmptyWhileStmt</rulename>
<description>发现空的while表达式，如果是一个定时的循环，你应该在循环体内使用 Thread.sleep()；如果是对于退出处理做的一个处理大量事情的while循环，重写代码使它更清晰。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-5</id>
<rulename>ReturnFromFinallyBlock</rulename>
<description>避免从 finally 块中返回 。</description>
<ruletype>代码规范</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>1-2</id>
<rulename>ForLoopShouldBeWhileLoop</rulename>
<description>有些for循环可以简化为 while循环-这样可以更加简明。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-29</id>
<rulename>StringToString</rulename>
<description>避免对字符串对象调用toString()方法，这是不必要的。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-11</id>
<rulename>MisplacedNullCheck</rulename>
<description>这里的空检查是放错位置的。如果变量为空你将得到一个空指针异常。可能因为检查是无用的或者是不正确的。如：if (!string.equals("") &amp;&amp; string!=null){}。</description>
<ruletype>代码规范</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>1-31</id>
<rulename>UnnecessaryCaseChange</rulename>
<description>使用equalsIgnoreCase()比将字符串大小写转换一致后再比较要快。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-53</id>
<rulename>EmptySwitchStatements</rulename>
<description>避免空的 switch表达式。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-54</id>
<rulename>EmptySynchronizedBlock</rulename>
<description>避免空的 synchronized 块 - 它们是无用的。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-48</id>
<rulename>EmptyCatchBlock</rulename>
<description>发现空的 catch 块没做任何异常处理的事，在大多数情形下，这会吞噬一些应该被处理或报告的异常。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>1-16</id>
<rulename>AvoidUsingHardCodedIP</rulename>
<description>一个应用中的硬编码 IP将使系统在某些情况下无法发布（例如内网IP暴露）。</description>
<ruletype>代码规范</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>1-13</id>
<rulename>BrokenNullCheck</rulename>
<description>如果自身抛出空指针异常空检查就会遭到破坏，比如你使用 ||代替 &amp;&amp;，反之亦然，如（应是&amp;&amp;）：if (string!=null || !string.equals("")){}。</description>
<ruletype>代码规范</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>1-36</id>
<rulename>InefficientEmptyStringCheck</rulename>
<description>用String.trim().length()来判断字符串是否空是低效的做法，因为它会创建一个新的字符串对象然后判断大小。考虑创建一个静态的方法循环String，用isWhitespace()检查每个字符如果遇到非空白字符就返回false。</description>
<ruletype>代码规范</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>2-7</id>
<rulename>NotificationRule</rulename>
<description>NotificationManage每次调用notify()方法时需要新建一个RemoteViews</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>2-11</id>
<rulename>FIRELINE_ODR_OPEN_DATABASE_RESOURCE</rulename>
<description>数据库操作相关的资源对象没有关闭。</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>2-6</id>
<rulename>ContextSoftReferenceRule</rulename>
<description>在callback函数参数中的Context或Activity建议使用SoftReference或 WeakReference</description>
<ruletype>内存类</ruletype>
<priority>3</priority>
</pass>
<pass>
<id>2-5</id>
<rulename>ContextRule</rulename>
<description>Context尽量使用 ApplicationContext而不要使用ActivityContext</description>
<ruletype>内存类</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>2-4</id>
<rulename>ParcelRecycleRule</rulename>
<description>Parcel使用后需要recycle</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>2-3</id>
<rulename>BitmapRecycleRule</rulename>
<description>Bitmap使用后需要recycle</description>
<ruletype>内存类</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>2-15</id>
<rulename>FIRELINE_OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE</rulename>
<description>资源对象在被关闭或者Return之前可能出现异常，导致无法正常关闭或Return。比如连续关闭多个资源对象时没有进行异常捕获，或者资源对象在Return之前进行了未捕获异常的操作。</description>
<ruletype>内存类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>3-2</id>
<rulename>LogAssignmentRule</rulename>
<description>不要在Log方法中对变量进行赋值操作。</description>
<ruletype>日志类</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>3-1</id>
<rulename>LogBlockRule</rulename>
<description>Log中不要输出敏感信息,例如pid、uid、imei号等。</description>
<ruletype>日志类</ruletype>
<priority>0</priority>
</pass>
<pass>
<id>4-9</id>
<rulename>DDosBlockRule</rulename>
<description>如果Intent在使用时未做异常处理，并且该intent所在的activity组件被设置为导出，且没有对调用者身份进行判断或访问权限控制，这种情况下会导致拒绝服务。</description>
<ruletype>安全类</ruletype>
<priority>0</priority>
</pass>
<pass>
<id>4-11</id>
<rulename>CheckIntentParseUriRule</rulename>
<description>Android中Activity设置为导出时，当使用intent进行应用内部或应用之间的数据传输时，如果组件没有正确的处理数据来源，可能会导致安全问题。</description>
<ruletype>安全类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>4-4</id>
<rulename>SqlrawQueryRule</rulename>
<description>对Content Provider进行增删改查操作时，程序没有对用户的输入进行过滤，未采用参数化查询的方式，可能导致sql注入攻击。</description>
<ruletype>安全类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>4-14</id>
<rulename>FragmentRule</rulename>
<description>导出的Activity继承PreferenceActivity,且Activity里未重写 PreferenceActivity.isValidFragment方法，这将会导致受害者应用敏感数据泄露、权限被滥用、拒绝服务、代码执行等。</description>
<ruletype>安全类</ruletype>
<priority>0</priority>
</pass>
<pass>
<id>4-3</id>
<rulename>ActivityExportedOverMuchRule</rulename>
<description>AndroidManifest.xml文件中组件导出过多，可能导致敏感界面被独立启动造成越权绕过。</description>
<ruletype>安全类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>4-2</id>
<rulename>SharedPerferenceDataRule</rulename>
<description>用SharedPreference来保存数据时，对于敏感信息的key需使用缩写或者其他不易知其意的命名，比如：KEY_PHONENUMBER, KEY_SERVER_IP_ADDRESS，应该改为KEY_P_N, KEY_S_I_A等。</description>
<ruletype>安全类</ruletype>
<priority>0</priority>
</pass>
<pass>
<id>4-1</id>
<rulename>WebViewRule</rulename>
<description>使用Webview的时候需要将setAllowFileAccess()和setJavaScriptEnabled()置为false来禁止文件系统访问，禁止对JavaScript的支持。最好统一规范，提供CommonWebView进行控制。</description>
<ruletype>安全类</ruletype>
<priority>0</priority>
</pass>
<pass>
<id>4-13</id>
<rulename>DebuggableRule</rulename>
<description>建议将AndroidMannifest.xml文件android:debuggable属性设置为false。当debuggable标志值为true时，该程序可被任意调试，导致APP被恶意攻击者控制。</description>
<ruletype>安全类</ruletype>
<priority>1</priority>
</pass>
<pass>
<id>4-7</id>
<rulename>protectionLevelRule</rulename>
<description>自定义权限时使用protectionLevel的默认值或显示设置为normal，会导致权限泄露。对于敏感权限建议设置为signature或者signatureOrSystem。</description>
<ruletype>安全类</ruletype>
<priority>2</priority>
</pass>
<pass>
<id>4-5</id>
<rulename>OpenFileRule</rulename>
<description>如果扫描到应用provider组件导出，且没有做权限限制，组件重写了ContentProvider.openFile()函数，却没有调用File.getCanonicalPath()函数进行过滤，存在安全隐患。</description>
<ruletype>安全类</ruletype>
<priority>0</priority>
</pass>
</passes>
</redline>
